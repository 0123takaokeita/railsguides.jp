Railsのスレッディングとコード実行
=====================================

このガイドの内容:

* Railsが自動的にコンカレント実行するコードの種類
* Rails内部で手動のコンカレンシーを統合する
* アプリのコード全体をラップする方法
* アプリの再読み込みに反映する方法

--------------------------------------------------------------------------------

自動コンカレンシー
---------------------

railsは、さまざまな操作を自動的に同時に実行できます。

Pumaなどのスレッド化されたWebサーバーを使えば、複数のHTTPリクエストを同時に処理し、各リクエストに独自のコントローラインスタンスを割り当てることができます。

スレッド化されたActive Jobアダプター（組み込みのAsyncを含む）も、これと同様に複数のジョブを同時に実行できます。Action Cableのチャンネルも同様に管理されます。

これらのメカニズムはいずれもマルチスレッド（multiple thread）に関連しており、グローバルプロセス空間（クラスとその設定、グローバルなど）を共有しながら、個別の処理を何らかのオブジェクト（コントローラやジョブやチャンネルなど）の唯一のインスタンスで管理します。共有されている部分をコードで変更しない限り、他のスレッドの存在をほとんど無視できます。

本ガイドの後半では、Railsが他のスレッドを「ほとんど無視できる」ようにするためのメカニズムや、特殊なニーズのある拡張やアプリがこのメカニズムを利用するしくみについて解説します。

エグゼキューター
--------

Railsエグゼキューターは、アプリのコードをフレームワークのコードから分離し、自分で書いたアプリのコードがフレームワークから呼び出されるたびにそのコードをラップします。

エグゼキューターは`to_run`および`to_complete`という2つのコールバックで構成されます。`to_run`コールバックはアプリコードの実行前に呼び出され、`to_complete`コールバックはアプリコードの実行後に呼び出されます。

### デフォルトのコールバック

エグゼキューターのコールバックは、デフォルトのRailsアプリで次の目的に使われます。

* 自動読み込み/再読み込み時にどのスレッドが安全な位置にあるかをトラッキングする
* Active Recordクエリキャッシュを有効または無効にする
* 獲得したActive Recordコネクションをプールに返す
* 内部キャッシュの生存期間（lifetime）に制限をかける

Rails 5.0より前の場合、上の一部は個別のRackミドルウェアクラス（`ActiveRecord::ConnectionAdapters::ConnectionManagement`など）や、メソッドを直接ラップするコード（`ActiveRecord::Base.connection_pool.with_connection`など）によって扱われていました。エグゼキューターは、これらをより抽象度の高い単一インターフェイスに置き換えるものです。

### アプリのコードをラップする

アプリのコードを呼び出すライブラリやコンポーネントを書くときには、次のようにエグゼキューター呼び出しでラップすべきです。

```ruby
Rails.application.executor.wrap do
  # ここでアプリのコードを呼ぶ
end
```

TIP: 長期間動き続けるプロセスからアプリのコードを繰り返し呼び出す場合は、代わりにリローダーでラップしましょう。

各スレッドは、スレッドがアプリのコードを実行する前にラップされるべきです。したがって、アプリが処理を別のスレッドに手動で委譲する場合（`Thread.new`や、スレッドプールを用いるConcurrent Ruby機能などを利用して）は、次のようにそのブロックを直ちにラップすべきです。

```ruby
Thread.new do
  Rails.application.executor.wrap do
    # ここに自分のコードを書く
  end
end
```

NOTE: Concurrent Rubyで使われる`ThreadPoolExecutor`は、`executor`オプションで設定されることがあります。名前は似ていますが、これはエグゼキューターとは無関係です。

エグゼキューターは安全に再入可能（re-entrant）です。現在のスレッドでエグゼキューターが既にアクティブになっている場合は、`wrap`は何も行いません。

アプリのコードをブロックでラップすると実用上困る場合（ラップするとRack APIで問題が生じる場合など）は、`run!`と`complete!`をペアで使うこともできます。

If it's impractical to wrap the application code in a block (for
example, the Rack API makes this problematic), you can also use the `run!` /
`complete!` pair:

```ruby
Thread.new do
  execution_context = Rails.application.executor.run!
  # ここに自分のコードを書く
ensure
  execution_context.complete! if execution_context
end
```

### コンカレンシー

エグゼキューターは、現在のスレッドをLoad Interlockで`running`モードにします。この操作は、別のスレッドが定数を自動読み込みしているかアプリをunload/リロードしている場合に一時的にブロッキングされます。


リローダー
--------

リローダーも、エグゼキューターと同様にアプリのコードをラップします。エグゼキューターが現在のスレッドで既にアクティブではなくなった場合、リローダーが代わりに呼び出しを行うので、コードを呼び出すだけで済みます。これにより、リローダーが行うあらゆる処理（あらゆるコールバック呼び出しを含む）がエグゼキューターの内部でラップされることが保証されます。

```ruby
Rails.application.reloader.wrap do
  # ここでアプリのコードを読む
end
```

リローダーは、長期間動くフレームワークレベルのプロセス（Webサーバーやジョブキューなど）からアプリのコードを繰り返し呼び出す場合にのみ適しています。RailsはWebリクエストやActive Jobワーカーを自動的にラップするので、リローダーをコード自身のために呼び出す必要性はめったにありません。常に、エグゼキューターが自分のユースケースに合うかを最初に検討してください。

### コールバック

ラップされたブロックが実行される前に、実行中のアプリを再読み込みするかどうかをリローダーがチェックします（モデルのソースファイルが変更された場合など）。再読み込みが必要であることが検出されると、安全になるまで待ってから再読み込みを行い、それから処理を続行します。変更が検出されるかどうかにかかわらず常に再読み込みを行うようにアプリが設定されている場合は、代わりにブロックの末尾で再読み込みを実行します。

リローダーも`to_run`および`to_complete`コールバックを提供しています。これらコールバックが呼び出される箇所はエグゼキューターの場合と同じですが、現在の実行がアプリの再読み込みを開始した場合にのみ呼び出される点が異なります。再読み込みが必要でないと判断されると、リローダーはラップされたブロックを他のコールバックなしで呼び出します。

### Class Unload

プロセスの再読み込みでもっとも重要なのはClass Unloadです。自動読込されたクラスはここで削除されて、再読み込み可能な状態になります。この処理は、`reload_classes_only_on_change`設定に応じて、RunコールバックかCompleteコールバックの直前で直ちに行われます。

Class Unloadの直前または直後に別の再読み込み操作を追加する必要が生じることがしばしばあるため、リローダーには`before_class_unload`コールバックや`after_class_unload`コールバックも提供されています。

### コンカレンシー

リローダーを呼び出すのは、長期間動作する「トップレベルの」プロセスに限るべきです。というのも、再読み込みが必要と判断された場合に、他のすべてのスレッドでエグゼキューター呼び出しが完全に終わるまでプロセスがブロッキングされてしまうからです。

仮に「子」スレッドでこれが発生し、しかも待機中の親がエグゼキューター内部にある場合、回避不可能なデッドロックが発生するでしょう。再読み込みは必ず子スレッド実行前に行われなければなりませんが、親スレッドが実行中だと再読み込みを安全に実行できなくなってしまいます。子スレッドではエグゼキューターを使うべきです。

フレームワークの振る舞い
------------------

Railsフレームワークのコンポーネントも、上述のツールを用いてコンポーネント自身のコンカレンシーの必要性を管理します。

`ActionDispatch::Executor`および`ActionDispatch::Reloader`は、提供されるエグゼキューターまたはリローダーでそれぞれリクエストをラップするRackミドルウェアです。どちらもデフォルトのアプリケーションスタックに自動で含まれます。アプリのコードで変更が生じると、リローダーはすべてのHTTPリクエストが新しく読み込まれたアプリで処理されるようにします。

Active Jobもジョブ実行をリローダーでラップします。キューが発生したときに最新のコードを読み込んで各ジョブを実行します。

Action Cableではリローダーではなくエグゼキューターを用います。Action Cableコネクションは、あるクラスの特定のインスタンスとつながるため、Websocketメッセージを受け取るたびに再読み込みするのは不可能です。ラップされるのはメッセージハンドラのみですが、長期間動作するAction Cableコネクションでは、新しいリクエストやジョブを受け取ったときに再読み込みのトリガーを抑制しません。その代わり、Action Cableではリローダーの`before_class_unload`コールバックを用いて全コネクションを切断します。クライアントが自動的に再接続すると、新しいコードが使われるようになります。

上述したのはフレームワークのエントリポイントであり、対応するスレッドを保護する責務と、再読み込みが必要かどうかを決定する責務を担います。これら以外のコンポーネントでは、追加のスレッドを生成するときにエグゼキューターのみを用います。

### 設定

リローダーは、`cache_classes`がfalseかつ`reload_classes_only_on_change`がtrue（`development`環境ではこれがデフォルト）の場合にのみ、ファイルが変更されたかどうかをチェックします。

`cache_classes`がtrue（`production`ではこれがデフォルト）の場合、リローダーは処理を単にエグゼキューターにパススルーします。

エグゼキューターは常に、データベース接続の管理によく似た重要な役割を担っています。`cache_classes`と`eager_load`がどちらもtrue（`production`）の場合、自動読み込みもクラス再読み込みも行われないため、Load Interlockは不要になります。いずれかがfalse（`development`）の場合、エグゼキューターはLoad Interlockを用いて、安全な場合にのみ定数が読み込まれるようにします。

Load Interlock
--------------

Load Interlockは、マルチスレッドのランタイム環境で自動読み込みや再読み込みを実現します。

適切なファイルにあるクラス定義を評価したことによって、あるスレッドで自動読み込みが実行されるときは、定義が完了していない定数を他のスレッドが参照しないようにすることが重要です。

同様に、unloadや再読み込みを安全に行えるタイミングは、実行中のアプリコードが1つもない場合しかありません。さもないと、再読み込み後にたとえば`User`定数が別のクラスを指してしまうかもしれません。このルールに従わないと、再読み込みがまずいタイミングで発生したときに`User.new.class == User`がfalseになったり、下手をすると`User == User`すらfalseになってしまうかもしれません。

こうした制限を是正するのがLoad Interlockです。アプリのコードを現在実行しているのがどのスレッドであるか、クラスを現在読み込んでいるのがどのスレッドであるか、自動読み込みされた定数を現在unloadしているのはどのスレッドであるかをトラッキングします。

読み込みやunloadを行えるのは1度に1つのスレッドだけです。これらを実現するには、他のどのスレッドもアプリのコードを実行しなくなるまでスレッドが待たなければなりません。読み込み実行に備えて待機しているスレッドは、他のスレッドが読み込みを実行することを阻止しません（実際にはスレッド同士は協調動作しており、各スレッドの待機中の読み込みは、すべてのスレッドが一斉に動き出す前に実行されます）。
``
### `permit_concurrent_loads`

エグゼキューターは、ブロッキングが継続する間`running`ロックを自動的に取得します。自動読み込み機能は、これを`load`ロックに昇格しその後`running`ロックに戻すタイミングを認識します。

この他のブロッキング操作については、エグゼキューターブロック（アプリの全コードが含まれます）の内部で実行されますが、`running`ロックが不必要に保持される可能性もあります。自動読み込みされなければならない定数に別のスレッドがアクセスすると、デッドロックする可能性があります。

たとえば、`User`が読み込まれていない状態では、以下でデッドロックします。

```ruby
Rails.application.executor.wrap do
  th = Thread.new do
    Rails.application.executor.wrap do
      User # 内側のスレッドはここで待機する
           # 別のスレッドが実行中はUserを読み込めない
    end
  end

  th.join # 外側のスレッドは`running`ロックを握ったままここで待機する
end
```

このデッドロックを防ぐには、外側のスレッドで`permit_concurrent_loads`を実行する方法があります。このメソッドを呼び出すと、渡されたブロック内で自動読み込みされる可能性のある定数への参照をスレッドが解除しないよう保証します。これを保証する最も安全な方法は、ブロッキング呼び出しのできるだけ近くにこのメソッドを配置することです。


```ruby
Rails.application.executor.wrap do
  th = Thread.new do
    Rails.application.executor.wrap do
      User # 内側のスレッドは`load`ロックの取得と
           # Userの読み込みを行って続行できる
    end
  end

  ActiveSupport::Dependencies.interlock.permit_concurrent_loads do
    th.join # 外側のスレッドはここで待機するがロックはかけない
  end
end
```

次の例ではConcurrent Rubyを用います。

```ruby
Rails.application.executor.wrap do
  futures = 3.times.collect do |i|
    Concurrent::Future.execute do
      Rails.application.executor.wrap do
        # ここで何かする
      end
    end
  end

  values = ActiveSupport::Dependencies.interlock.permit_concurrent_loads do
    futures.collect(&:value)
  end
end
```


### `ActionDispatch::DebugLocks`

アプリのデッドロックがLoad Interlockと何か関わり合いがありそうだと思える場合、`ActionDispatch::DebugLocks`ミドルウェアを一時的に`config/application.rb`に追加できます。

```ruby
config.middleware.insert_before Rack::Sendfile,
                                  ActionDispatch::DebugLocks
```

次にアプリを再起動してデッドロック条件をトリガすると、Load Interlockで把握している現在の全スレッドの概要が`/rails/locks`に出力されます。現在保持または待機中のロックのレベルと、それらの現在のバックトレースが含まれます。

デッドロックは一般に、Load Interlockが何らかの外部ロックやブロッキングI/O呼び出しとコンフリクトするときに発生します。このコンフリクトに気づいたら、`permit_concurrent_loads`でラップしましょう。

