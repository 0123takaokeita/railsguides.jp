<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Ruby on Rails Guides</title>
<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />

<link rel="stylesheet" type="text/css" href="stylesheets/fixes.css" />

<link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong class="more-info-label">他の情報源: </strong>
      <span class="red-button more-info-button">
        他の情報源
      </span>
      <ul class="more-info-links s-hidden">
        <li class="more-info"><a href="http://guides.rubyonrails.org/">原著 (英語)</a></li>
        <li class="more-info"><a href="https://github.com/yasslab/railsguides.jp">ソースコード(GitHub)</a></li>
        <li class="more-info"><a href="http://railstutorial.jp/">Railsチュートリアル</a></li>
      </ul>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="/" title="Return to home page">railsguides.jp</a></h1>
      <ul class="nav">
        <li><a class="nav-item" href="index.html">ホーム</a></li>
        <li class="guides-index guides-index-large">
          <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">ガイド目次</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
              <dl class="L">
                <dt>はじめに</dt>
                <dd><a href="getting_started.html">Railsをはじめよう</a></dd>
                <dt>モデル</dt>
                <dd><a href="active_record_basics.html">Active Recordの基礎</a></dd>
                <dd><a href="active_record_migrations.html">Active Recordとマイグレーション (※翻訳中)</a></dd>
                <dd><a href="active_record_validations.html">Active Record検証機能 (バリデーション)</a></dd>
                <dd><a href="active_record_callbacks.html">Active Recordコールバック</a></dd>
                <dd><a href="association_basics.html">Active Recordの関連付け (アソシエーション)</a></dd>
                <dd><a href="active_record_querying.html">Active Recordクエリインターフェイス</a></dd>
                <dt>ビュー</dt>
                <dd><a href="layouts_and_rendering.html">ビューのレイアウトとレンダリング (※翻訳中)</a></dd>
                <dd><a href="form_helpers.html">Action Viewフォームヘルパー</a></dd>
                <dt>コントローラ</dt>
                <dd><a href="action_controller_overview.html">Action Controllerの概要</a></dd>
                <dd><a href="routing.html">Railsのルーティング (※翻訳中)</a></dd>
              </dl>
              <dl class="R">
                <dt>高度なトピック</dt>
                <dd><a href="active_support_core_extensions.html">Active Supportコア拡張機能</a></dd>
                <dd><a href="i18n.html">Rails国際化(I18n) API</a></dd>
                <dd><a href="action_mailer_basics.html">Action Mailerの基礎 (未着手)</a></dd>
                <dd><a href="active_job_basics.html">Active Jobの基礎 (未着手)</a></dd>
                <dd><a href="security.html">Ruby on Railsセキュリティガイド</a></dd>
                <dd><a href="debugging_rails_applications.html">Railsアプリケーションのデバッグ (未着手)</a></dd>
                <dd><a href="configuring.html">Railsアプリケーションを設定する</a></dd>
                <dd><a href="command_line.html">コマンドラインツールとRakeタスク (未着手)</a></dd>
                <dd><a href="asset_pipeline.html">アセットパイプライン (未着手)</a></dd>
                <dd><a href="working_with_javascript_in_rails.html">RailsでJavaScriptを使用する (未着手)</a></dd>
                <dt>Railsを拡張する</dt>
                <dd><a href="rails_on_rack.html">Rackに乗ったRails (未着手)</a></dd>
                <dd><a href="generators.html">Railsジェネレータの作成とカスタマイズ (未着手)</a></dd>
                <dt>Ruby on Railsに貢献する</dt>
                <dd><a href="contributing_to_ruby_on_rails.html">Ruby on Railsへの貢献方法 (未着手)</a></dd>
                <dd><a href="api_documentation_guidelines.html">APIドキュメントの書き方 (未着手)</a></dd>
                <dd><a href="ruby_on_rails_guides_guidelines.html">Ruby on Railsガイドのガイドライン</a></dd>
                <dt>メンテナンスポリシー</dt>
                <dd><a href="maintenance_policy.html">メンテナンスポリシー (未着手)</a></dd>
                <dt>リリースノート</dt>
                <dd><a href="upgrading_ruby_on_rails.html">Ruby on Railsアップグレードガイド</a></dd>
                <dd><a href="4_1_release_notes.html">Ruby on Rails 4.1リリースノート</a></dd>
                <dd><a href="4_0_release_notes.html">Ruby on Rails 4.0リリースノート (未着手)</a></dd>
                <dd><a href="3_2_release_notes.html">Ruby on Rails 3.2リリースノート (未着手)</a></dd>
                <dd><a href="3_1_release_notes.html">Ruby on Rails 3.1リリースノート (未着手)</a></dd>
                <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0リリースノート (未着手)</a></dd>
                <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3リリースノート (未着手)</a></dd>
                <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2リリースノート (未着手)</a></dd>
              </dl>
          </div>
        </li>
        <li><a class="nav-item" href="contributing_to_ruby_on_rails.html">貢献方法</a></li>
        <li><a class="nav-item" href="credits.html">原著者</a></li>
        <li class="guides-index guides-index-small">
          <select class="guides-index-item nav-item">
            <option value="index.html">ガイド目次</option>
              <optgroup label="はじめに">
                  <option value="getting_started.html">Railsをはじめよう</option>
              </optgroup>
              <optgroup label="モデル">
                  <option value="active_record_basics.html">Active Recordの基礎</option>
                  <option value="active_record_migrations.html">Active Recordとマイグレーション (※翻訳中)</option>
                  <option value="active_record_validations.html">Active Record検証機能 (バリデーション)</option>
                  <option value="active_record_callbacks.html">Active Recordコールバック</option>
                  <option value="association_basics.html">Active Recordの関連付け (アソシエーション)</option>
                  <option value="active_record_querying.html">Active Recordクエリインターフェイス</option>
              </optgroup>
              <optgroup label="ビュー">
                  <option value="layouts_and_rendering.html">ビューのレイアウトとレンダリング (※翻訳中)</option>
                  <option value="form_helpers.html">Action Viewフォームヘルパー</option>
              </optgroup>
              <optgroup label="コントローラ">
                  <option value="action_controller_overview.html">Action Controllerの概要</option>
                  <option value="routing.html">Railsのルーティング (※翻訳中)</option>
              </optgroup>
              <optgroup label="高度なトピック">
                  <option value="active_support_core_extensions.html">Active Supportコア拡張機能</option>
                  <option value="i18n.html">Rails国際化(I18n) API</option>
                  <option value="action_mailer_basics.html">Action Mailerの基礎 (未着手)</option>
                  <option value="active_job_basics.html">Active Jobの基礎 (未着手)</option>
                  <option value="security.html">Ruby on Railsセキュリティガイド</option>
                  <option value="debugging_rails_applications.html">Railsアプリケーションのデバッグ (未着手)</option>
                  <option value="configuring.html">Railsアプリケーションを設定する</option>
                  <option value="command_line.html">コマンドラインツールとRakeタスク (未着手)</option>
                  <option value="asset_pipeline.html">アセットパイプライン (未着手)</option>
                  <option value="working_with_javascript_in_rails.html">RailsでJavaScriptを使用する (未着手)</option>
              </optgroup>
              <optgroup label="Railsを拡張する">
                  <option value="rails_on_rack.html">Rackに乗ったRails (未着手)</option>
                  <option value="generators.html">Railsジェネレータの作成とカスタマイズ (未着手)</option>
              </optgroup>
              <optgroup label="Ruby on Railsに貢献する">
                  <option value="contributing_to_ruby_on_rails.html">Ruby on Railsへの貢献方法 (未着手)</option>
                  <option value="api_documentation_guidelines.html">APIドキュメントの書き方 (未着手)</option>
                  <option value="ruby_on_rails_guides_guidelines.html">Ruby on Railsガイドのガイドライン</option>
              </optgroup>
              <optgroup label="メンテナンスポリシー">
                  <option value="maintenance_policy.html">メンテナンスポリシー (未着手)</option>
              </optgroup>
              <optgroup label="リリースノート">
                  <option value="upgrading_ruby_on_rails.html">Ruby on Railsアップグレードガイド</option>
                  <option value="4_1_release_notes.html">Ruby on Rails 4.1リリースノート</option>
                  <option value="4_0_release_notes.html">Ruby on Rails 4.0リリースノート (未着手)</option>
                  <option value="3_2_release_notes.html">Ruby on Rails 3.2リリースノート (未着手)</option>
                  <option value="3_1_release_notes.html">Ruby on Rails 3.1リリースノート (未着手)</option>
                  <option value="3_0_release_notes.html">Ruby on Rails 3.0リリースノート (未着手)</option>
                  <option value="2_3_release_notes.html">Ruby on Rails 2.3リリースノート (未着手)</option>
                  <option value="2_2_release_notes.html">Ruby on Rails 2.2リリースノート (未着手)</option>
              </optgroup>
          </select>
        </li>
      </ul>
      </div>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      
                <div id="subCol">
            <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
            <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<ol class="chapters">
<li>
<a href="#ae22c61bf10bc278f8133f37fe2e18d174997fa5">データベースからオブジェクトを取り出す</a>

<ul>
<li><a href="#bd8b27244468167e17701f3ee89397a8afde6781">単一のオブジェクトを取り出す</a></li>
<li><a href="#1fa4af89975d70e85b488033c82f5cd536d5c7f5">複数のオブジェクトを取り出す</a></li>
<li><a href="#105f77fa4f1090be63ab292646ba8cb12164b988">複数のオブジェクトをバッチで取り出す</a></li>
</ul>
</li>
<li>
<a href="#72f1cf759c9bbec57dd3ffad345b1163f5d3b5f7">条件</a>

<ul>
<li><a href="#bace25266a0da96af4237fb8be546b43e60be3f0">文字列だけで表された条件</a></li>
<li><a href="#a7ca35ea32cd2a5ad32ccbfc7a1aa72def183f58">配列で表された条件</a></li>
<li><a href="#e51dac3fd5a4e80cbdb871051f572e832e0b5a49">ハッシュを使用した条件</a></li>
<li><a href="#71e6c693b32995796124c284582668ce7edef9de">NOT条件</a></li>
</ul>
</li>
<li><a href="#53283c8d2af83b313b792aa5c7d788f2f5ad2cfe">並び順</a></li>
<li><a href="#8be9391962bfda3defcbcd659b1032fbec0050c5">特定のフィールドだけを取り出す</a></li>
<li><a href="#f327149ff9e882dc0f32c94c5c3dc4df19d741e3">LimitとOffset</a></li>
<li><a href="#7769eea4413b1212495a9afbe62538149207ae0b">グループ</a></li>
<li><a href="#9a3aa20fbb9238e4176e03594d12d5c6b257d499">Having</a></li>
<li>
<a href="#b94c6c5d3b71cb592ade6ce94e3bf4c6ad358ec7">条件を上書きする</a>

<ul>
<li><a href="#1ffac49ec2695698ce3f3ca714b8a4ce36143c62"><code>unscope</code></a></li>
<li><a href="#f8969a18a0daab6f59b42990613def0b8b6d48eb"><code>only</code></a></li>
<li><a href="#dda179e1684b61273216a299abd522f79e926a8b"><code>reorder</code></a></li>
<li><a href="#ef844e68f9373351b9759cd547153833bc36f538"><code>reverse_order</code></a></li>
<li><a href="#00651b3e9a55b8b01228bf2e33dafb64fd6bc5df"><code>rewhere</code></a></li>
</ul>
</li>
<li><a href="#054c0a3eece59cfd0bb4df59ad7b0b04427a1f4d">Nullリレーション</a></li>
<li><a href="#0fb1fdc2d947480a814cb943bbe3f92469a06c85">読み取り専用オブジェクト</a></li>
<li>
<a href="#89851d8eec9d580a070acebdd9d1b234a1e93940">レコードを更新できないようロックする</a>

<ul>
<li><a href="#7c68a8ca2d1bfd37da9b6728e73e071e593d5737">楽観的ロック (optimistic)</a></li>
<li><a href="#dd002486bb5efafe18ffe3754bd8878df28ce40a">悲観的ロック</a></li>
</ul>
</li>
<li>
<a href="#dcda096ceb51bea1fb5b5ce7618358f42a0742d1">テーブルを結合する</a>

<ul>
<li><a href="#02d179cb5826b5a4a2e77a850f07e87a3719f290">SQLフラグメント文字列を使用する</a></li>
<li><a href="#cc80bc594fd5fd15572c869ca95351dc94be7a09">名前付き関連付けの配列/ハッシュを使用する</a></li>
<li><a href="#9f95289b508d205e24ad9c7005e44b99f97ad920">結合されたテーブルで条件を指定する</a></li>
</ul>
</li>
<li>
<a href="#e6628909fdb58f2af8c839dc6661eb4b1f11120c">関連付けを一括読み込みする</a>

<ul>
<li><a href="#bd4ffe8cc153741ce244f380bf3d15bbeb809222">複数の関連付けを一括で読み込む</a></li>
<li><a href="#bdb25cb8a8e635bb7bd8c1f5bb77b0ffad05e564">関連付けの一括読み込みで条件を指定する</a></li>
</ul>
</li>
<li>
<a href="#80c416ae601b58a3896fe8cbfbe58add01de2edd">スコープ</a>

<ul>
<li><a href="#ad06f70c2eabd0215ef0af184188d6e10a260664">引数を渡す</a></li>
<li><a href="#51690a62ca6d15ba543cab48c70376b784d94a60">スコープのマージ</a></li>
<li><a href="#30be9500c100be41fd74af24a93103db6a113331">デフォルトスコープを適用する</a></li>
<li><a href="#f0350a39e67ea218b045c5362a0334817955eddc">すべてのスコープを削除する</a></li>
</ul>
</li>
<li><a href="#3159fe57a05148ef94a9a31139e7bbdb36483a37">動的ファインダ</a></li>
<li>
<a href="#90c056472865ae1cb910bca46dd845509fc4a140">新しいオブジェクトを検索またはビルドする</a>

<ul>
<li><a href="#ebcf2a5d1bdc4dc82a9e5281737958a5e7c1ddc4"><code>find_or_create_by</code></a></li>
<li><a href="#731ec2ca341f448e807c7b093db72f730c213520"><code>find_or_create_by!</code></a></li>
<li><a href="#c3ef7f82dbe298d394ea9a3a1b1238c3c441b24b"><code>find_or_initialize_by</code></a></li>
</ul>
</li>
<li>
<a href="#288aac771c26e37f2e1c93e40363cfaa1e17d23f">SQLで検索する</a>

<ul>
<li><a href="#da9177abda199cc6e93fa67326c93fc9bdf82464"><code>select_all</code></a></li>
<li><a href="#07542ad08b8353036c3f43fd7fbb4ea166f300fb"><code>pluck</code></a></li>
<li><a href="#3adc09b3cd3d7c4710f562a05bd850e756cba1b8"><code>ids</code></a></li>
</ul>
</li>
<li><a href="#6a25a0f94fd29020e437623892e55e8fb0a649ac">オブジェクトの存在チェック</a></li>
<li>
<a href="#c2bfc727f263555f4d523b8ec46ff97d8ac36d20">計算</a>

<ul>
<li><a href="#5cb355f0034d2cab93b851ef559183fc981e44eb">個数を数える</a></li>
<li><a href="#d1454ec0221e46f8a0f10116910c45d454860592">平均</a></li>
<li><a href="#c0d224e7d5a80249cae39bd7df303bfa8178d931">最小値</a></li>
<li><a href="#0c5fcc52f1964e3da3538f4796d65659d8019aa1">最大値</a></li>
<li><a href="#1db118371c67e76c6733174f05fa65e2d00fbb88">合計</a></li>
</ul>
</li>
<li>
<a href="#3c724550ef43da451a0b97d6da617dc5e771250d">EXPLAINを実行する</a>

<ul>
<li><a href="#49e58308c3ccb67c8e3961eadaa51f3a1f461fca">EXPLAINの出力結果を解釈する</a></li>
</ul>
</li>
</ol>
</body></html>

          </div>
</div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<h2>Active Recordクエリインターフェイス</h2>
<p>このガイドでは、Active Recordを使用してデータベースからデータを取り出すためのさまざまな方法について解説します。</p>
<p>このガイドの内容:</p>
<ul>
<li>多くのメソッドや条件を駆使してレコードを検索する</li>
<li>検索されたレコードのソート順、取り出したい属性、グループ化の有無などを指定する</li>
<li>eager loadingを使用して、データ取り出しに必要なクエリの実行回数を減らす</li>
<li>動的検索メソッドを使用する</li>
<li>特定のレコードが存在するかどうかをチェックする</li>
<li>Active Recordモデルでさまざまな計算を行う</li>
<li>リレーションでHEXPLAINを実行する</li>
</ul>

<hr>
<p>生のSQLを使用してデータベースのレコードを検索することに慣れきった人がRailsに出会うと、Railsでは同じ操作をずっと洗練された方法で実現できることに気付くでしょう。Active Recordを使用することで、SQLを直に実行する必要はほぼなくなります。</p>
<p>本ガイドのコード例では、基本的に以下のモデルを使用します。</p>
<p>メモ: 特に記さない限り、モデル中の<code>id</code>は主キーを表します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Address &lt; ActiveRecord::Base
  belongs_to :client
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Order &lt; ActiveRecord::Base
  belongs_to :client, counter_cache: true
end

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Role &lt; ActiveRecord::Base
  has_and_belongs_to_many :clients
end

</pre>
</div>
<p>Active Recordは、ユーザーに代わってデータベースにクエリを発行します。発行されるクエリは多くのデータベースシステム (MySQL、PostgreSQL、SQLiteなど) と互換性があります。Active Recordを使用していれば、利用しているデータベースシステムの種類にかかわらず、同じ表記を使用できます。</p>
<h3 id="ae22c61bf10bc278f8133f37fe2e18d174997fa5">1 データベースからオブジェクトを取り出す</h3>
<p>Active Recordでは、データベースからオブジェクトを取り出すための検索メソッドを多数用意しています。これらの検索メソッドを使用することで、生のSQLを書くことなく、データベースへの特定のクエリを実行するための引数を渡すことができます。</p>
<p>以下のメソッドが用意されています。</p>
<ul>
<li><code>bind</code></li>
<li><code>create_with</code></li>
<li><code>distinct</code></li>
<li><code>eager_load</code></li>
<li><code>extending</code></li>
<li><code>from</code></li>
<li><code>group</code></li>
<li><code>having</code></li>
<li><code>includes</code></li>
<li><code>joins</code></li>
<li><code>limit</code></li>
<li><code>lock</code></li>
<li><code>none</code></li>
<li><code>offset</code></li>
<li><code>order</code></li>
<li><code>preload</code></li>
<li><code>readonly</code></li>
<li><code>references</code></li>
<li><code>reorder</code></li>
<li><code>reverse_order</code></li>
<li><code>select</code></li>
<li><code>uniq</code></li>
<li><code>where</code></li>
</ul>
<p>上のメソッドは、すべて<code>ActiveRecord::Relation</code>のインスタンスを返します。</p>
<p><code>Model.find(options)</code>という操作を要約すると以下のようになります。</p>
<ul>
<li>与えられたオプションを同等のSQLクエリに変換します。</li>
<li>SQLクエリを発行し、該当する結果をデータベースから取り出します。</li>
<li>得られた結果を行ごとに同等のRubyオブジェクトとしてインスタンス化します。</li>
<li>必要であれば<code>after_find</code>コールバックを実行します。</li>
</ul>
<h4 id="bd8b27244468167e17701f3ee89397a8afde6781">1.1 単一のオブジェクトを取り出す</h4>
<p>Active Recordには、単一のオブジェクトを取り出すためのさまざま方法が用意されています。</p>
<h5 id="7a125e4c680a8cd60d853cbd0ee3393056e7b750">1.1.1 主キーを使用する</h5>
<p><code>Model.find(primary_key)</code>を使用すると、与えられたどのオプションにもマッチする <em>主キー</em> に対応するオブジェクトを取り出すことができます。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Find the client with primary key (id) 10.
client = Client.find(10)
# =&gt; #&lt;Client id: 10, first_name: "Ryan"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1

</pre>
</div>
<p><code>Model.find(primary_key)</code>でマッチするレコードが見つからない場合、<code>ActiveRecord::RecordNotFound</code>例外が発生します。</p>
<h5 id="bd8b27244468167e17701f3ee89397a8afde6781-53bd7d992ed7edf9a271056d254d8f7797462f27">1.1.2 <code>take</code>
</h5>
<p><code>Model.take</code>はレコードを1つ取り出します。このとき、どのレコードが取り出されるかは指定されません。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.take
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 1

</pre>
</div>
<p>モデルにレコードが1つもない場合は<code>Model.take</code>は<code>nil</code>を返します。このとき例外は発生しません。</p>
<p>メモ: このメソッドでどのレコードが取り出されるかは、使用するデータベースエンジンによって異なることがあります。</p>
<h5 id="bd8b27244468167e17701f3ee89397a8afde6781-e0996a37c13d44c3b06074939d43fa3759bd32c1">1.1.3 <code>first</code>
</h5>
<p><code>Model.first</code>は、主キー順の最初のレコードを取り出します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.first
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1

</pre>
</div>
<p>モデルにレコードが1つもない場合は<code>Model.first</code>は<code>nil</code>を返します。このとき例外は発生しません。</p>
<h5 id="bd8b27244468167e17701f3ee89397a8afde6781-213ed3ea453bf610688ff8041e0a3b7b6abb5e6e">1.1.4 <code>last</code>
</h5>
<p><code>Model.last</code>は、主キー順の最後のレコードを取り出します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.last
# =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1

</pre>
</div>
<p>モデルにレコードが1つもない場合は<code>Model.last</code>は<code>nil</code>を返します。このとき例外は発生しません。</p>
<h5 id="90f22ae95225edbeffe0480d49a9a8cb25819312">1.1.5 <code>find_by</code>
</h5>
<p><code>Model.find_by</code> は、与えられた条件にマッチするレコードのうち最初のレコードだけを返します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by first_name: 'Lifo'
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

Client.find_by first_name: 'Jon'
# =&gt; nil

</pre>
</div>
<p>上の文は以下のように書くこともできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Lifo').take

</pre>
</div>
<h5 id="0f4f41b911b0b464bd09bb5eb7b79cf5bed144eb">1.1.6 <code>take!</code>
</h5>
<p><code>Model.take!</code>は、レコードを1つ取り出します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.take!
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 1

</pre>
</div>
<p><code>Model.take!</code>でマッチするレコードが見つからない場合、<code>ActiveRecord::RecordNotFound</code>例外が発生します。</p>
<h5 id="e632d9891cd3544861881db32e73e2fe859a2d62">1.1.7 <code>first!</code>
</h5>
<p><code>Model.first!</code>は、主キー順の最初のレコードを取り出します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.first!
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1

</pre>
</div>
<p><code>Model.first!マッチするレコードが見つからない場合、</code>ActiveRecord::RecordNotFound`例外が発生します。</p>
<h5 id="20900a835a77166cd9926b38270b7af175c3a9a1">1.1.8 <code>last!</code>
</h5>
<p><code>Model.last!</code>は、主キー順の最後のレコードを取り出します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.last!
# =&gt; #&lt;Client id: 221, first_name: "Russel"&gt;

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1

</pre>
</div>
<p><code>Model.last!</code>でマッチするレコードが見つからない場合、<code>ActiveRecord::RecordNotFound</code>例外が発生します。</p>
<h5 id="046ae9d4ffdd6f74e82a984edd5245650da0e11f">1.1.9 <code>find_by!</code>
</h5>
<p><code>Model.find_by!</code> は、与えられた条件にマッチするレコードのうち最初のレコードだけを返します。マッチするレコードが見つからない場合、<code>ActiveRecord::RecordNotFound</code>例外が発生します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by! first_name: 'Lifo'
# =&gt; #&lt;Client id: 1, first_name: "Lifo"&gt;

Client.find_by! first_name: 'Jon'
# =&gt; ActiveRecord::RecordNotFound

</pre>
</div>
<p>上の文は以下のように書くこともできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Lifo').take! 

</pre>
</div>
<h4 id="1fa4af89975d70e85b488033c82f5cd536d5c7f5">1.2 複数のオブジェクトを取り出す</h4>
<h5 id="bf5a43a464eb72606528533c330ea93b37e532cb">1.2.1 複数の主キーを使用する</h5>
<p><code>Model.find()</code> は <em>主キー</em> の配列を受け付け、与えられた <em>主キー</em> にマッチするすべてのレコードを配列の形で返します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Or even Client.find(1, 10)
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;, #&lt;Client id: 10, first_name: "Ryan"&gt;]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.id IN (1,10))

</pre>
</div>
<p>警告: <code>Model.find(array_of_primary_key)</code>は、与えられた主キーのうち1つでもマッチしなければ<code>ActiveRecord::RecordNotFound</code>例外を発生します。</p>
<h5 id="1fa4af89975d70e85b488033c82f5cd536d5c7f5-53bd7d992ed7edf9a271056d254d8f7797462f27">1.2.2 take</h5>
<p><code>Model.take(limit)</code>は、<code>limit</code>で指定された数だけレコードを取り出します。このとき取り出し順は指定できません。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.take(2)
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;,
      #&lt;Client id: 2, first_name: "Raf"&gt;]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 2

</pre>
</div>
<h5 id="1fa4af89975d70e85b488033c82f5cd536d5c7f5-e0996a37c13d44c3b06074939d43fa3759bd32c1">1.2.3 first</h5>
<p><code>Model.first(limit)</code>は、主キー順の最初から、<code>limit</code>で指定された数だけレコードを取り出します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.first(2)
# =&gt; [#&lt;Client id: 1, first_name: "Lifo"&gt;,
      #&lt;Client id: 2, first_name: "Raf"&gt;]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY id ASC LIMIT 2

</pre>
</div>
<h5 id="1fa4af89975d70e85b488033c82f5cd536d5c7f5-213ed3ea453bf610688ff8041e0a3b7b6abb5e6e">1.2.4 last</h5>
<p><code>Model.last(limit)</code>は、主キー順の最後から、<code>limit</code>で指定された数だけレコードを取り出します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.last(2)
# =&gt; [#&lt;Client id: 10, first_name: "Ryan"&gt;,
      #&lt;Client id: 9, first_name: "John"&gt;]

</pre>
</div>
<p>これと同等のSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients ORDER BY id DESC LIMIT 2

</pre>
</div>
<h4 id="105f77fa4f1090be63ab292646ba8cb12164b988">1.3 複数のオブジェクトをバッチで取り出す</h4>
<p>多数のレコードに対して反復処理を行いたいことがあります。たとえば、多くのユーザーにニュースレターを送信したい、データをエクスポートしたいなどです。</p>
<p>このような処理をそのまま実装すると以下のようになるでしょう。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# このような処理を数千件ものレコードに対して実行すると、効率が大幅に低下します。
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end

</pre>
</div>
<p>しかし上のような処理は、テーブルのサイズが大きくなるにつれて非現実的になります。<code>User.all.each</code>は、Active Recordに対して <em>テーブル全体</em> を一度に取り出し、しかも1行ごとにオブジェクトを生成し、その巨大なモデルオブジェクトの配列をメモリに配置するからです。もし莫大な数のレコードに対してこのようなコードをまともに実行すると、コレクション全体のサイズがメモリ容量を上回ってしまうことでしょう。</p>
<p>Railsでは、メモリを圧迫しないサイズにバッチを分割して処理するための方法を2とおり提供しています。1つ目は<code>find_each</code>メソッドを使用する方法です。これは、レコードのバッチを1つ取り出し、次に <em>各</em> レコードを1つのモデルとして個別にブロックにyieldします。2つ目の方法は<code>find_in_batches</code>メソッドを使用する方法です。レコードのバッチを1つ取り出し、次に <em>バッチ全体</em> をモデルの配列としてブロックにyieldします。</p>
<p>ヒント: <code>find_each</code>メソッドと<code>find_in_batches</code>メソッドは、一度にメモリに読み込めないような大量のレコードに対するバッチ処理のためのものです。数千のレコードに対して単にループ処理を行なうのであれば通常の検索メソッドで十分です。</p>
<h5 id="be888d8b7a6d5aa2364f77106b1fed307184abda">1.3.1 <code>find_each</code>
</h5>
<p><code>find_each</code>メソッドは、レコードのバッチを1つ取り出し、続いて <em>各</em> レコードを1つのモデルとして個別にブロックにyieldします。以下の例では、<code>find_each</code>で1000件のレコードを取り出しています。この件数は<code>find_each</code>と<code>find_in_batches</code>のどちらでもデフォルト値として使用されており、続いて各レコードを1つのモデルとしてブロックに個別にyieldします。この処理は、すべてのレコードが処理されるまで繰り返されます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end

</pre>
</div>
<h6 id="625dd5d02e06988f3f38f19b308be3941191fe48">1.3.1.1 <code>find_each</code>のオプション</h6>
<p><code>find_each</code>メソッドでは、通常の<code>find</code>メソッドとほぼ同じオプションが使用できます。<code>:order</code>と<code>:limit</code>は<code>find_each</code>内部で利用するために予約されており、使用できません。</p>
<p>通常のオプションの他に、<code>:batch_size</code>オプションと<code>:start</code>オプションも使用できます。</p>
<p><strong><code>:batch_size</code></strong></p>
<p><code>:batch_size</code>オプションは、(ブロックに個別に渡される前に) 1回のバッチで取り出すレコード数を指定します。たとえば、1回に5000件ずつ処理したい場合は以下のように指定します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each(batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end

</pre>
</div>
<p><strong><code>:start</code></strong></p>
<p>デフォルトでは、レコードは主キーの昇順に取り出されます。主キーは整数でなければなりません。並び順冒頭のIDが不要な場合、<code>:start</code>オプションを使用してシーケンスの開始IDを指定します。これは、たとえば中断したバッチ処理を再開する場合などに便利です (最後に実行された処理のIDがチェックポイントとして保存済みであることが前提です)。</p>
<p>たとえば、1回のバッチで5000件を取り出し、主キーが2000以降のユーザーだけにニュースレターを送信したい場合は以下のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.find_each(start: 2000, batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end

</pre>
</div>
<p>他にも、同じ処理キューを複数の作業者で手分けする場合が考えられます。<code>start</code>オプションを適切に使用して、作業者1人につき10000レコードずつ割り当てるといった利用法です。</p>
<h5 id="aaa4c36bf28e206e07e457c6c6eb9b1ef75f776f">1.3.2 <code>find_in_batches</code>
</h5>
<p><code>find_in_batches</code>メソッドは、レコードをバッチで取り出すという点で<code>find_each</code>と似ています。違うのは、<code>find_in_batches</code>は <em>バッチ</em> を個別にではなくモデルの配列としてブロックにyieldするという点です。以下の例では、与えられたブロックに対して一度に最大1000までの納品書 (invoice) の配列をyieldしています。最後のブロックには残りの納品書が含まれます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# 1回あたりadd_invoicesに納品書1000通の配列を渡す
Invoice.find_in_batches(include: :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end

</pre>
</div>
<p>メモ: <code>:include</code>オプションを使用すると、モデルとともに読み込まれる関連付けに名前を付けることができます。</p>
<h6 id="110b0b3341dd49b683355095da475fc92c32a69f">1.3.2.1 <code>find_in_batches</code>のオプション</h6>
<p><code>find_in_batches</code>メソッドでは、<code>find_each</code>メソッドと同様、通常の<code>find</code>メソッド用オプションに加えて<code>:batch_size</code>オプションや<code>:start</code>オプションが使用できます。<code>:order</code>と<code>:limit</code>は<code>find_in_batches</code>内部で利用するために予約されており、使用できません。</p>
<h3 id="72f1cf759c9bbec57dd3ffad345b1163f5d3b5f7">2 条件</h3>
<p><code>where</code>メソッドは、返されるレコードを制限するための条件を指定します。SQL文で言う<code>WHERE</code>の部分に相当します。条件は、文字列、配列、ハッシュのいずれかの方法で与えることができます。</p>
<h4 id="bace25266a0da96af4237fb8be546b43e60be3f0">2.1 文字列だけで表された条件</h4>
<p>検索メソッドに条件を追加したい場合、たとえば<code>Client.where("orders_count = '2'")</code>のように条件を単純に指定することができます。この場合、<code>orders_count</code>フィールドの値が2であるすべてのクライアントが検索されます。</p>
<p>警告: 条件を文字列だけで構成すると、SQLインジェクションの脆弱性が発生する可能性があります。たとえば、<code>Client.where("first_name LIKE '%#{params[:first_name]}%'")</code>という書き方は危険です。次で説明するように、配列を使用するのが望ましい方法です。</p>
<h4 id="a7ca35ea32cd2a5ad32ccbfc7a1aa72def183f58">2.2 配列で表された条件</h4>
<p>条件で使用する数値が変動する可能性がある場合、引数をどのようにすればよいでしょうか。この場合は以下のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ?", params[:orders])

</pre>
</div>
<p>Active Recordは条件値の最初の要素を調べ、その後に要素が追加されていたら、最初の要素の中にある疑問符<code>(?)</code>を追加要素で置き換えます。</p>
<p>複数の条件を指定したい場合は次のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ? AND locked = ?", params[:orders], false)

</pre>
</div>
<p>上の例では、1つ目の疑問符は<code>params[:orders]</code>の値で置き換えられ、2つ目の疑問符は<code>false</code>をSQL形式に変換したもの (変換方法はアダプタによって異なる) で置き換えられます。</p>
<p>以下のようなコードの書き方を強く推奨します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = ?", params[:orders])

</pre>
</div>
<p>以下の書き方は危険であり、避ける必要があります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count = #{params[:orders]}")

</pre>
</div>
<p>条件文字列の中に変数を直接置くと、その変数はデータベースに <strong>そのまま</strong> 渡されてしまいます。これは、悪意のある人物がエスケープされていない危険な変数を渡すことができるということです。このようなコードがあると、悪意のある人物がデータベースを意のままにすることができ、データベース全体が危険にさらされます。くれぐれも、条件文字列の中に引数を直接置くことはしないでください。</p>
<p>ヒント: SQLインジェクションの詳細については<a href="security.html#sql-injection">Ruby on Railsセキュリティガイド</a> を参照してください。</p>
<h5 id="7abaeba108126c1880214947849168837ea8562e">2.2.1 プレースホルダを使用した条件</h5>
<p>疑問符<code>(?)</code>をパラメータで置き換えるスタイルと同様、配列による条件中でキー/値のハッシュを指定できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})

</pre>
</div>
<p>このように書くことで、条件で多数の変数が使用されている場合にコードが読みやすくなります。</p>
<h4 id="e51dac3fd5a4e80cbdb871051f572e832e0b5a49">2.3 ハッシュを使用した条件</h4>
<p>Active Recordは条件をハッシュで渡すこともできます。この書式を使用することで条件構文が読みやすくなります。条件をハッシュで渡す場合、ハッシュのキーには条件付けしたいフィールドを、ハッシュの値にはそのフィールドをどのように条件づけするかを、それぞれ指定します。</p>
<p>メモ: ハッシュによる条件は、等値、範囲、サブセットのチェックでのみ使用できます。</p>
<h5 id="59fec4e3edad1915a6d18dcb2822604f6e41cd5e">2.3.1 等値条件</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(locked: true)

</pre>
</div>
<p>フィールド名は文字列形式にすることもできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where('locked' =&gt; true)

</pre>
</div>
<p>belongs_toリレーションシップの場合、Active Recordオブジェクトが値として使用されていれば、モデルを指定する時に関連付けキーを使用できます。この方法はポリモーフィックリレーションシップでも同様に使用できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where(author: author)
Author.joins(:posts).where(posts: { author: author })

</pre>
</div>
<p>メモ: この値はシンボルにすることはできません。たとえば<code>Client.where(status: :active)</code>のような書き方はできません。</p>
<h5 id="8673f385991be1fe714b1de57229beb0e4530835">2.3.2 範囲条件</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

</pre>
</div>
<p>上の例では、昨日作成されたすべてのクライアントを検索します。内部ではSQLの<code>BETWEEN</code>文が使用されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')

</pre>
</div>
<p><a href="#array-conditions">配列による条件</a> ではさらに簡潔な文例をご紹介しています。</p>
<h5 id="928a69ab42eb4e4953112ab0dd2a62cb02d23eca">2.3.3 サブセット条件</h5>
<p>SQLの<code>IN</code>式を使用してレコードを検索したい場合、条件ハッシュにそのための配列を1つ渡すことができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(orders_count: [1,3,5])

</pre>
</div>
<p>上のコードを実行すると、以下のようなSQLが生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))

</pre>
</div>
<h4 id="71e6c693b32995796124c284582668ce7edef9de">2.4 NOT条件</h4>
<p>SQLの<code>NOT</code>クエリは、<code>where.not</code>で表せます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where.not(author: author)

</pre>
</div>
<p>言い換えれば、このクエリは<code>where</code>に引数を付けずに呼び出し、直後に<code>where</code>条件に<code>not</code>を渡して連鎖させることによって生成されています。</p>
<h3 id="53283c8d2af83b313b792aa5c7d788f2f5ad2cfe">3 並び順</h3>
<p>データベースから取り出すレコードを特定の順序で並べ替えたい場合、<code>order</code>を使用できます。</p>
<p>たとえば、ひとかたまりのレコードを取り出し、それをテーブル内の<code>created_at</code>の昇順で並べたい場合には以下のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(:created_at)
# または
Client.order("created_at")

</pre>
</div>
<p><code>ASC</code>(昇順)や<code>DESC</code>(降順)を指定することもできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(created_at: :desc)
# または
Client.order(created_at: :asc)
# または
Client.order("created_at DESC")
# または
Client.order("created_at ASC")

</pre>
</div>
<p>複数のフィールドを指定して並べることもできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order(orders_count: :asc, created_at: :desc)
# または
Client.order(:orders_count, created_at: :desc)
# または
Client.order("orders_count ASC, created_at DESC")
# または
Client.order("orders_count ASC", "created_at DESC")

</pre>
</div>
<p><code>order</code>メソッドを(条件を変えて)複数回呼び出したい場合、最初の条件に新しい条件が追加されます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC

</pre>
</div>
<h3 id="8be9391962bfda3defcbcd659b1032fbec0050c5">4 特定のフィールドだけを取り出す</h3>
<p>デフォルトでは、<code>Model.find</code>を実行すると、結果セットからすべてのフィールドが選択されます。内部的にはSQLの<code>select *</code>が実行されています。</p>
<p>結果セットから特定のフィールドだけを取り出したい場合、<code>select</code>メソッドを使用できます。</p>
<p>たとえば、<code>viewable_by</code>カラムと<code>locked</code>カラムだけを取り出したい場合は以下のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select("viewable_by, locked")

</pre>
</div>
<p>上で実際に使用されるSQL文は以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT viewable_by, locked FROM clients

</pre>
</div>
<p>selectを使用すると、選択したフィールドだけを使用してモデルオブジェクトが初期化されるため、注意してください。モデルオブジェクトの初期化時に指定しなかったフィールドにアクセスしようとすると、以下のメッセージが表示されます。</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
ActiveModel::MissingAttributeError: missing attribute: &lt;属性名&gt; 

</pre>
</div>
<p><code>&lt;属性名&gt;</code>は、アクセスしようとした属性です。<code>id</code>メソッドは、この<code>ActiveRecord::MissingAttributeError</code>を発生しません。このため、関連付けを扱う場合には注意してください。関連付けが正常に動作するには<code>id</code>メソッドが必要だからです。</p>
<p>特定のフィールドについて、重複のない一意の値を1レコードだけ取り出したい場合、<code>distinct</code>を使用できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select(:name).distinct

</pre>
</div>
<p>上のコードを実行すると、以下のようなSQLが生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT DISTINCT name FROM clients

</pre>
</div>
<p>一意性の制約を外すこともできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
query = Client.select(:name).distinct
# =&gt; 重複のない一意の名前が返される

query.distinct(false)
# =&gt; 重複の有無を問わずすべての名前が返される

</pre>
</div>
<h3 id="f327149ff9e882dc0f32c94c5c3dc4df19d741e3">5 LimitとOffset</h3>
<p><code>Model.find</code>で実行されるSQLに<code>LIMIT</code>を適用したい場合、リレーションで<code>limit</code>メソッドと<code>offset</code>メソッドを使用することで<code>LIMIT</code>を指定できます。</p>
<p><code>limit</code>メソッドは、取り出すレコード数の上限を指定します。<code>offset</code>は、レコードを返す前にスキップするレコード数を指定します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.limit(5)

</pre>
</div>
<p>上を実行するとクライアントが最大で5つ返されます。オフセットは指定されていないので、最初の5つがテーブルから取り出されます。この時実行されるSQLは以下のような感じになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 5

</pre>
</div>
<p><code>offset</code>を追加すると以下のようになります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.limit(5).offset(30)

</pre>
</div>
<p>上のコードは、最初の30クライアントをスキップして31人目から最大5人のクライアントを返します。このときのSQLは以下のようになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 5 OFFSET 30

</pre>
</div>
<h3 id="7769eea4413b1212495a9afbe62538149207ae0b">6 グループ</h3>
<p>検索メソッドで実行されるSQLに<code>GROUP BY</code>句を追加したい場合は、<code>group</code>メソッドを検索メソッドに追加できます。</p>
<p>たとえば、注文 (order) の作成日のコレクションを検索したい場合は、以下のようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")

</pre>
</div>
<p>上のコードは、データベースで注文のある日付ごとに<code>Order</code>オブジェクトを1つ作成します。</p>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)

</pre>
</div>
<h3 id="9a3aa20fbb9238e4176e03594d12d5c6b257d499">7 Having</h3>
<p>SQLでは、<code>GROUP BY</code>フィールドで条件を指定する場合に<code>HAVING</code>句を使用します。検索メソッドで<code>:having</code>オプションを使用すると、<code>Model.find</code>で生成されるSQLに<code>HAVING</code>句を追加できます。</p>
<p>例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) &gt; ?", 100)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) &gt; 100

</pre>
</div>
<p>上の例では、1日あたり1つの注文 (order) オブジェクトを返しますが、1日あたりの注文合計が$100を超える場合にのみこれを行います。</p>
<h3 id="b94c6c5d3b71cb592ade6ce94e3bf4c6ad358ec7">8 条件を上書きする</h3>
<h4 id="1ffac49ec2695698ce3f3ca714b8a4ce36143c62">8.1 <code>unscope</code>
</h4>
<p><code>unscope</code>を使用して特定の条件を取り除くことができます。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where('id &gt; 10').limit(20).order('id asc').except(:order)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE id &gt; 10 LIMIT 20

# `unscope`する前のオリジナルのクエリ
SELECT * FROM posts WHERE id &gt; 10 ORDER BY id asc LIMIT 20


</pre>
</div>
<p>特定のwhere句で<code>unscope</code>を指定することもできます。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "posts".* FROM "posts" WHERE trashed = 0

</pre>
</div>
<p><code>unscope</code>をリレーションに適用すると、それにマージされるすべてのリレーションにも影響します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.order('id asc').merge(Post.unscope(:order))
# SELECT "posts".* FROM "posts"

</pre>
</div>
<h4 id="f8969a18a0daab6f59b42990613def0b8b6d48eb">8.2 <code>only</code>
</h4>
<p><code>only</code>メソッドを使用すると、条件を上書きできます。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE id &gt; 10 ORDER BY id DESC

# Original query without `only`
SELECT "posts".* FROM "posts" WHERE (id &gt; 10) ORDER BY id desc LIMIT 20


</pre>
</div>
<h4 id="dda179e1684b61273216a299abd522f79e926a8b">8.3 <code>reorder</code>
</h4>
<p><code>reorder</code>メソッドは、デフォルトのスコープの並び順を上書きします。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  ..
  ..
  has_many :comments, -&gt; { order('posted_at DESC') }
end

Post.find(10).comments.reorder('name')

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE id = 10 ORDER BY name

</pre>
</div>
<p>In case the <code>reorder</code> clause is not used, the SQL executed would be:</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE id = 10 ORDER BY posted_at DESC

</pre>
</div>
<h4 id="ef844e68f9373351b9759cd547153833bc36f538">8.4 <code>reverse_order</code>
</h4>
<p><code>reverse_order</code>メソッドは、並び順が指定されている場合に並び順を逆にします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count &gt; 10").order(:name).reverse_order

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY name DESC

</pre>
</div>
<p>SQLクエリで並び順を指定する句がない場合に<code>reverse_order</code>を実行すると、主キーの逆順になります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where("orders_count &gt; 10").reverse_order

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE orders_count &gt; 10 ORDER BY clients.id DESC

</pre>
</div>
<p>This method accepts <strong>no</strong> arguments.</p>
<h4 id="00651b3e9a55b8b01228bf2e33dafb64fd6bc5df">8.5 <code>rewhere</code>
</h4>
<p><code>rewhere</code>メソッドは、既存のwhere条件を上書きします。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where(trashed: true).rewhere(trashed: false)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE `trashed` = 0

</pre>
</div>
<p><code>rewhere</code>の代わりに<code>where</code>を2回使用すると、以下のようになってしまいます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.where(trashed: true).where(trashed: false)

</pre>
</div>
<p>上で実行されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM posts WHERE `trashed` = 1 AND `trashed` = 0

</pre>
</div>
<h3 id="054c0a3eece59cfd0bb4df59ad7b0b04427a1f4d">9 Nullリレーション</h3>
<p><code>none</code>メソッドは、連鎖 (chain) 可能なリレーションを返します (レコードは返しません)。このメソッドから返されたリレーションにどのような条件を連鎖しても、常に空のリレーションが生成されます。これは、メソッドまたはスコープへの連鎖可能な応答が必要で、しかも結果を一切返したくない場合に便利です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.none # 空のリレーションを返し、クエリを生成しない。

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# 以下のvisible_postsメソッドはリレーションを1つ返すことが期待されている
@posts = current_user.visible_posts.where(name: params[:name])

def visible_posts
  case role
  when 'Country Manager'
    Post.where(country: country)
  when 'Reviewer'
    Post.published
  when 'Bad User'
    Post.none # =&gt; この場合[]またはnilを返し、呼び出し側のコードを中断する
  end
end

</pre>
</div>
<h3 id="0fb1fdc2d947480a814cb943bbe3f92469a06c85">10 読み取り専用オブジェクト</h3>
<p>Active Recordには、返されたどのオブジェクトに対しても変更を明示的に禁止する<code>readonly</code>メソッドがあります。読み取り専用を指定されたオブジェクトに対する変更の試みはすべて失敗し、<code>ActiveRecord::ReadOnlyRecord</code>例外が発生します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
client = Client.readonly.first
client.visits += 1
client.save

</pre>
</div>
<p>上のコードでは <code>client</code>に対して明示的に<code>readonly</code>が指定されているため、 <em>visits</em> の値を更新して <code>client.save</code>を行なうと<code>ActiveRecord::ReadOnlyRecord</code>例外が発生します。</p>
<h3 id="89851d8eec9d580a070acebdd9d1b234a1e93940">11 レコードを更新できないようロックする</h3>
<p>ロックは、データベースのレコードを更新する際の競合状態を避け、アトミックな (=中途半端な状態のない) 更新を行なうために有用です。</p>
<p>Active Recordには2とおりのロック機構があります。</p>
<ul>
<li>楽観的ロック (optimistic)</li>
<li>悲観的ロック (pessimistic)</li>
</ul>
<h4 id="7c68a8ca2d1bfd37da9b6728e73e071e593d5737">11.1 楽観的ロック (optimistic)</h4>
<p>楽観的ロックでは、複数のユーザーが同じレコードを編集することを許し、データの衝突が最小限であることを仮定しています。この方法では、レコードがオープンされてから変更されたことがあるかどうかをチェックします。そのような変更が行われ、かつ更新が無視された場合、<code>ActiveRecord::StaleObjectError</code>例外が発生します。</p>
<p><strong>楽観的ロックカラム</strong></p>
<p>楽観的ロックを使用するには、テーブルに<code>lock_version</code>という名前のinteger型カラムがある必要があります。Active Recordは、レコードが更新されるたびに<code>lock_version</code>カラムの値を1ずつ増やします。更新リクエストが発生したときの<code>lock_version</code>の値がデータベース上の<code>lock_version</code>カラムの値よりも小さい場合、更新リクエストは失敗し、<code>ActiveRecord::StaleObjectError</code>エラーが発生します。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # ActiveRecord::StaleObjectErrorを発生

</pre>
</div>
<p>例外の発生後、この例外をレスキューすることで衝突を解決する必要があります。衝突の解決方法は、ロールバック、マージ、またはビジネスロジックに応じた解決方法のいずれかを使用してください。</p>
<p><code>ActiveRecord::Base.lock_optimistically = false</code>を設定するとこの動作をオフにできます。</p>
<p><code>ActiveRecord::Base</code>には、<code>lock_version</code>カラム名を上書きするための<code>locking_column</code>が用意されています。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  self.locking_column = :lock_client_column
end

</pre>
</div>
<h4 id="dd002486bb5efafe18ffe3754bd8878df28ce40a">11.2 悲観的ロック</h4>
<p>悲観的ロックでは、データベースが提供するロック機構を使用します。リレーションの構築時に<code>lock</code>を使用すると、選択した行に対する排他的ロックを取得できます。<code>lock</code>を使用するリレーションは、デッドロック条件を回避するために通常トランザクションの内側にラップされます。</p>
<p>例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save
end

</pre>
</div>
<p>バックエンドでMySQLを使用している場合、上のセッションによって以下のSQLが生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT

</pre>
</div>
<p>異なる種類のロックを使用したい場合、<code>lock</code>メソッドに生のSQLを渡すこともできます。たとえば、MySQLには<code>LOCK IN SHARE MODE</code>という式があります。これはレコードのロック中にも他のクエリからの読み出しは許可するものです。この式を指定するには、単にlockオプションの引数にします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end

</pre>
</div>
<p>モデルのインスタンスが既にある場合は、トランザクションを開始してその中でロックを一度に取得できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
item = Item.first
item.with_lock do
  # このブロックはトランザクション内で呼び出される
  # itemはロック済み
  item.increment!(:views)
end

</pre>
</div>
<h3 id="dcda096ceb51bea1fb5b5ce7618358f42a0742d1">12 テーブルを結合する</h3>
<p>Active Recordの検索メソッドには<code>joins</code>があり、生成されたSQLで<code>JOIN</code>句を使用できます。<code>joins</code>メソッドにはさまざまな使用方法があります。</p>
<h4 id="02d179cb5826b5a4a2e77a850f07e87a3719f290">12.1 SQLフラグメント文字列を使用する</h4>
<p><code>joins</code>メソッドの引数に生のSQLを指定することで<code>JOIN</code>句を指定できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')

</pre>
</div>
<p>これによって以下のSQLが生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id

</pre>
</div>
<h4 id="cc80bc594fd5fd15572c869ca95351dc94be7a09">12.2 名前付き関連付けの配列/ハッシュを使用する</h4>
<p>警告: このメソッドは<code>INNER JOIN</code>でしか使用できません。</p>
<p>Active Recordでは、<code>joins</code>メソッドを使用して関連付けで<code>JOIN</code>句を指定する際に、モデルで定義された<a href="association_basics.html">関連付け</a> の名前をショートカットとして使用できます。</p>
<p>たとえば、以下の<code>Category</code>、<code>Post</code>、<code>Comment</code>、<code>Guest</code>、<code>Tag</code>モデルについて考えてみましょう。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Category &lt; ActiveRecord::Base
  has_many :posts
end

class Post &lt; ActiveRecord::Base
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment &lt; ActiveRecord::Base
  belongs_to :post
  has_one :guest
end

class Guest &lt; ActiveRecord::Base
  belongs_to :comment
end

class Tag &lt; ActiveRecord::Base
  belongs_to :post
end

</pre>
</div>
<p>以下のすべてにおいて、<code>INNER JOIN</code>を使用した結合クエリが期待どおりに生成されています。</p>
<h5 id="0f48610fa785c364db4d6e51810e8ee8f37d68d9">12.2.1 単一関連付けを結合する</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.joins(:posts)

</pre>
</div>
<p>上によって以下が生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id

</pre>
</div>
<p>上のSQLを日本語で書くと「投稿 (post) のあるすべてのカテゴリーを含む、Categoryオブジェクトを1つ返す」となります。なお、同じカテゴリーに複数の投稿がある場合、カテゴリーが重複します。重複のない一意のカテゴリーが必要な場合は、<code>Category.joins(:posts).uniq</code>を使用できます。</p>
<h5 id="f0f78d37d5598fa8fdd5e229683f7d5a2faaa99a">12.2.2 複数の関連付けを結合する</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.joins(:category, :comments)

</pre>
</div>
<p>上によって以下が生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT posts.* FROM posts
  INNER JOIN categories ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id

</pre>
</div>
<p>上のSQLを日本語で書くと、「カテゴリーが1つあり、かつコメントが少なくとも1つある、すべての投稿を返す」となります。こちらも、コメントが複数ある投稿は複数回表示されます。</p>
<h5 id="420421074f32899a14598952e5be248453c68d09">12.2.3 ネストした関連付けを結合する (単一レベル)</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.joins(comments: :guest)

</pre>
</div>
<p>上によって以下が生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT posts.* FROM posts
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guests ON guests.comment_id = comments.id

</pre>
</div>
<p>上のSQLを日本語で書くと、「ゲストによるコメントが1つある投稿をすべて返す」となります。</p>
<h5 id="8b31d9b79bf7c9a7754640204348e0cd2168d4d8">12.2.4 ネストした関連付けを結合する (複数レベル)</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.joins(posts: [{ comments: :guest }, :tags])

</pre>
</div>
<p>上によって以下が生成されます。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.post_id = posts.id

</pre>
</div>
<h4 id="9f95289b508d205e24ad9c7005e44b99f97ad920">12.3 結合されたテーブルで条件を指定する</h4>
<p>標準の<a href="#array-conditions">配列</a>および<a href="#pure-string-conditions">文字列</a>条件を使用して、結合テーブルに条件を指定することができます。<a href="#hash-conditions">ハッシュ条件</a> の場合、結合テーブルで条件を指定する場合に特殊な構文を使用します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
time_range = (Time.now.midnight - 1.day).Time.now.midnight
Client.joins(:orders).where('orders.created_at' =&gt; time_range)

</pre>
</div>
<p>さらに読みやすい別の方法として、ハッシュ条件をネストさせる方法があります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
time_range = (Time.now.midnight - 1.day).Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })

</pre>
</div>
<p>このコードでは、昨日作成された注文 (order) を持つすべてのクライアントを検索します。ここでもSQLの<code>BETWEEN</code>式を使用しています。</p>
<h3 id="e6628909fdb58f2af8c839dc6661eb4b1f11120c">13 関連付けを一括読み込みする</h3>
<p>一括読み込み (eager loading) とは、<code>Model.find</code>によって返されるオブジェクトに関連付けられたレコードを読み込むためのメカニズムであり、できるだけクエリの使用回数を減らすようにします。</p>
<p><strong>N + 1クエリ問題</strong></p>
<p>以下のコードについて考えてみましょう。クライアントを10人検索して郵便番号を表示します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end

</pre>
</div>
<p>このコードは一見何の問題もないように見えます。しかし本当の問題は、実行されたクエリの回数が無駄に多いことなのです。上のコードでは、最初にクライアントを10人検索するのにクエリを1回発行し、次にそこから住所を取り出すのにクエリを10回発行しますので、合計で <strong>11</strong> 回のクエリが発行されます。</p>
<p><strong>N + 1クエリ問題を解決する</strong></p>
<p>Active Recordは、読み込まれるすべての関連付けを事前に指定することができます。これは、<code>Model.find</code>呼び出しで<code>includes</code>を指定することで実現できます。<code>includes</code>を指定すると、Active Recordは指定されたすべての関連付けが最小限のクエリ回数で読み込まれるようにしてくれます。</p>
<p>上の例で言うと、<code>Client.limit(10)</code>というコードを書き直して、住所が一括で読み込まれるようにします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end

</pre>
</div>
<p>最初の例では <strong>11</strong> 回もクエリが実行されましたが、今度の例ではわずか <strong>2</strong> 回にまで減りました。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))

</pre>
</div>
<h4 id="bd4ffe8cc153741ce244f380bf3d15bbeb809222">13.1 複数の関連付けを一括で読み込む</h4>
<p>Active Recordは、1つの<code>Model.find</code>呼び出しで関連付けをいくつでも一括読み込みすることができます。これを行なうには、<code>includes</code>メソッドで配列、ハッシュ、または、配列やハッシュのネストしたハッシュを使用します。</p>
<h5 id="667f8af98e9f7930582496405537eb29614ec2af">13.1.1 複数の関連付けの配列</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.includes(:category, :comments)

</pre>
</div>
<p>上のコードは、投稿と、それに関連付けられたカテゴリとコメントをすべて読み込みます。</p>
<h5 id="cca627e02c657a0e00b30b61839bbdf69505f192">13.1.2 ネストした関連付けハッシュ</h5>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Category.includes(posts: [{ comments: :guest }, :tags]).find(1)

</pre>
</div>
<p>上のコードは、id=1のカテゴリを検索し、関連付けられたすべての投稿およびそのタグとコメント、およびすべてのコメントのゲスト関連付けを一括読み込みします。</p>
<h4 id="bdb25cb8a8e635bb7bd8c1f5bb77b0ffad05e564">13.2 関連付けの一括読み込みで条件を指定する</h4>
<p>Active Recordでは、<code>joins</code>のように事前読み込みされた関連付けに対して条件を指定することができますが、<a href="#%E7%B5%90%E5%90%88%E3%81%99%E3%82%8B%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB">joins</a> という方法を使用することをお勧めします。</p>
<p>しかし、このようにせざるを得ない場合は、<code>where</code>を通常どおりに使用することができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.includes(:comments).where("comments.visible" =&gt; true)

</pre>
</div>
<p>このコードは、<code>LEFT OUTER JOIN</code>を含むクエリを1つ生成します。<code>joins</code>メソッドを使用していたら、代りに<code>INNER JOIN</code>を使用するクエリが生成されていたでしょう。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
  SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)

</pre>
</div>
<p><code>where</code>条件がない場合は、通常のクエリが2セット生成されます。</p>
<p>この<code>includes</code>クエリの場合、どの投稿にもコメントがついていないで、やはりすべての投稿が読み込まれるでしょう。<code>joins</code> (INNER JOIN) を使用する場合、結合条件は必ずマッチ <strong>しなければならず</strong> 、それ以外の場合にはレコードは返されません。</p>
<h3 id="80c416ae601b58a3896fe8cbfbe58add01de2edd">14 スコープ</h3>
<p>スコープを設定することで、関連オブジェクトやモデルへのメソッド呼び出しとして参照される、よく使用されるクエリを指定することができます。スコープでは、<code>where</code>、<code>joins</code>、<code>includes</code>など、これまでに登場したすべてのメソッドを使用できます。どのスコープメソッドも、常に<code>ActiveRecord::Relation</code>オブジェクトを返します。このオブジェクトに対して、別のスコープを含む他のメソッド呼び出しを行なうこともできます。</p>
<p>単純なスコープを設定するには、クラスの内部で<code>scope</code>メソッドを使用し、スコープが呼び出されたときに実行して欲しいクエリをそこで渡します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  scope :published, -&gt; { where(published: true) }
end

</pre>
</div>
<p>以下でもわかるように、スコープでのメソッドの設定は、クラスメソッドの定義と完全に同じ (というよりクラスメソッドの定義そのもの) です。どちらの形式を使用するかは好みの問題です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  def self.published
    where(published: true)
  end
end

</pre>
</div>
<p>スコープをスコープ内で連鎖 (chain) させることもできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  scope :published,               -&gt; { where(published: true) }
  scope :published_and_commented, -&gt; { published.where("comments_count &gt; 0") }
end

</pre>
</div>
<p>この<code>published</code>スコープを呼び出すには、クラスでこのスコープを呼び出します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.published # =&gt; [published posts]

</pre>
</div>
<p>または、<code>Post</code>オブジェクトからなる関連付けでこのスコープを呼び出します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
category = Category.first
category.posts.published # =&gt; [published posts belonging to this category]

</pre>
</div>
<h4 id="ad06f70c2eabd0215ef0af184188d6e10a260664">14.1 引数を渡す</h4>
<p>スコープには引数を渡すことができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  scope :created_before, -&gt;(time) { where("created_at &lt; ?", time) }
end

</pre>
</div>
<p>引数付きスコープの呼び出しは、クラスメソッドの呼び出しと同様の方法で行います。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Post.created_before(Time.zone.now)

</pre>
</div>
<p>しかし、このスコープでできる機能は、クラスメソッドでできる機能と重複しています。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Post &lt; ActiveRecord::Base
  def self.created_before(time)
    where("created_at &lt; ?", time)
  end
end

</pre>
</div>
<p>スコープで引数を使用するのであれば、クラスメソッドとして定義する方が推奨されます。クラスメソッドにした場合でも、関連オブジェクトからアクセス可能です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
category.posts.created_before(time)

</pre>
</div>
<h4 id="51690a62ca6d15ba543cab48c70376b784d94a60">14.2 スコープのマージ</h4>
<p><code>where</code>句と同様、<code>AND</code>条件を使用してスコープをマージできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'

</pre>
</div>
<p><code>scope</code>と<code>where</code>条件を混用してマッチさせることができます。その結果生成される最終的なSQLには、すべての条件が<code>AND</code>で結合されて使用されます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'

</pre>
</div>
<p>スコープよりも最後のwhere句をどうしても優先したい場合は、<code>Relation#merge</code>を使用できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'

</pre>
</div>
<p>ここで一つ注意すべき点は、<code>default_scope</code>は
<code>scope</code>や<code>where</code>条件よりも前に置かれるという点です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class User &lt; ActiveRecord::Base
  default_scope { where state: 'pending' }
  scope :active, -&gt; { where state: 'active' }
  scope :inactive, -&gt; { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'

</pre>
</div>
<p>上の例でわかるように、<code>default_scope</code>が<code>scope</code>と<code>where</code>よりも前の場所にマージされています。</p>
<h4 id="30be9500c100be41fd74af24a93103db6a113331">14.3 デフォルトスコープを適用する</h4>
<p>あるスコープをモデルのすべてのクエリに適用したい場合、モデル自身の内部で<code>default_scope</code>メソッドを使用することができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  default_scope { where("removed_at IS NULL") }
end

</pre>
</div>
<p>このモデルに対してクエリが実行されたときのSQLクエリは以下のような感じになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE removed_at IS NULL

</pre>
</div>
<p>デフォルトスコープの条件が複雑になるのであれば、スコープをクラスメソッドとして定義するのもひとつの手です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  def self.default_scope
    # ActiveRecord::Relationを返すようにする
  end
end

</pre>
</div>
<h4 id="f0350a39e67ea218b045c5362a0334817955eddc">14.4 すべてのスコープを削除する</h4>
<p>何らかの理由でスコープをすべて解除したい場合は<code>unscoped</code>メソッドを使用できます。このメソッドは、モデルで<code>default_scope</code>が指定されているが、それを適用したくないクエリがある場合に特に便利です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.unscoped.load

</pre>
</div>
<p>このメソッドはスコープをすべて解除し、テーブルに対して通常の (スコープなしの) クエリを実行するようにします。</p>
<p><code>unscoped</code>に<code>scope</code>を連鎖させることはできませんので注意が必要です。このような場合は、<code>unscoped</code>のブロック形式を使用することが推奨されます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.unscoped {
  Client.created_before(Time.zone.now)
}

</pre>
</div>
<h3 id="3159fe57a05148ef94a9a31139e7bbdb36483a37">15 動的ファインダ</h3>
<p>Active Recordは、テーブルに定義されたすべてのフィールド (属性とも呼ばれます) に対して自動的にファインダメソッドを提供します。たとえば、<code>Client</code>モデルに<code>first_name</code>というフィールドがあると、<code>find_by_first_name</code>というメソッドがActive Recordによって自動的に作成されます。<code>Client</code>モデルに<code>locked</code>というフィールドがあれば、<code>find_by_locked</code>というメソッドを使用できます。</p>
<p>この動的ファインダメソッドの末尾に<code>Client.find_by_name!("Ryan")</code>のように感嘆符 (<code>!</code>) を追加すると、該当するレコードがない場合に<code>ActiveRecord::RecordNotFound</code>エラーが発生します。</p>
<p>nameとlockedの両方を検索したいのであれば、2つのフィールド名をandでつなぐだけでメソッドを利用できます。たとえば、<code>Client.find_by_first_name_and_locked("Ryan", true)</code>のように書くことができます。</p>
<h3 id="90c056472865ae1cb910bca46dd845509fc4a140">16 新しいオブジェクトを検索またはビルドする</h3>
<p>メモ: Rails 4.0では一部の動的ファインダメソッドが非推奨に指定されました。これらはRails 4.1で削除される予定です。最良の方法は、Active Recordのスコープを代りに使用することです。非推奨になったファインダgemは<a href="https://github.com/rails/activerecord-deprecated_finders%E3%81%AB%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82">https://github.com/rails/activerecord-deprecated_findersにあります。</a></p>
<p>レコードを検索し、レコードがなければ作成する、というのはよくある一連の流れです。<code>find_or_create_by</code>および<code>find_or_create_by!</code>メソッドを使用すればこれらを一度に行なうことができます。</p>
<h4 id="ebcf2a5d1bdc4dc82a9e5281737958a5e7c1ddc4">16.1 <code>find_or_create_by</code>
</h4>
<p><code>find_or_create_by</code>メソッドは、指定された属性を持つレコードが存在するかどうかをチェックします。レコードがない場合は<code>create</code>が呼び出されます。以下の例を見てみましょう。</p>
<p>'Andy'という名前のクライアントを探し、いなければ作成したいとします。これを行なうには以下を実行します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by(first_name: 'Andy')
# =&gt; #&lt;Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

</pre>
</div>
<p>このメソッドによって生成されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT

</pre>
</div>
<p><code>find_or_create_by</code>は、既にあるレコードか新しいレコードのいずれかを返します。上の例の場合、Andyという名前のクライアントがなかったのでレコードを作成して返しました。</p>
<p><code>create</code>などと同様、検証にパスするかどうかによって、新しいレコードがデータベースに保存されていないことがあるかもしれません。</p>
<p>今度は、新しいレコードを作成するときに'locked'属性を<code>false</code>に設定したいが、それをクエリに含めたくないとします。そこで、"Andy"という名前のクライアントを検索するか、その名前のクライアントがいない場合は"Andy"というクライアントを作成してロックを外すことにします。</p>
<p>これは2とおりの方法で実装できます。1つ目は<code>create_with</code>を使用する方法です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')

</pre>
</div>
<p>2つ目はブロックを使用する方法です。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end

</pre>
</div>
<p>このブロックは、クライアントが作成されるときにだけ実行されます。このコードを再度実行すると、このブロックは実行されません。</p>
<h4 id="731ec2ca341f448e807c7b093db72f730c213520">16.2 <code>find_or_create_by!</code>
</h4>
<p><code>find_or_create_by!</code>を使用すると、新しいレコードが無効な場合に例外を発生することもできます。このガイドでは検証については解説の対象ではありませんが、</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
validates :orders_count, presence: true

</pre>
</div>
<p>上を<code>Client</code>モデルに追加したとします。<code>orders_count</code>を指定しないで新しい<code>Client</code>モデルを作成しようとすると、レコードは無効になって例外が発生します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_or_create_by!(first_name: 'Andy')
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank

</pre>
</div>
<h4 id="c3ef7f82dbe298d394ea9a3a1b1238c3c441b24b">16.3 <code>find_or_initialize_by</code>
</h4>
<p><code>find_or_initialize_by</code>メソッドは<code>find_or_create_by</code>と同様に動作しますが、<code>create</code>の代りに<code>new</code>を呼ぶ点が異なります。つまり、モデルの新しいインスタンスは作成されますが、その時点ではデータベースに保存されていません。<code>find_or_create_by</code>の例を少し変えて説明を続けます。今度は'Nick'という名前のクライアントが必要だとします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
nick = Client.find_or_initialize_by(first_name: 'Nick')
# =&gt; &lt;Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

nick.persisted?
# =&gt; false

nick.new_record?
# =&gt; true

</pre>
</div>
<p>オブジェクトはまだデータベースに保存されていないため、生成されるSQLは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1

</pre>
</div>
<p>このオブジェクトをデータベースに保存したい場合は、単に<code>save</code>を呼び出します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
nick.save
# =&gt; true

</pre>
</div>
<h3 id="288aac771c26e37f2e1c93e40363cfaa1e17d23f">17 SQLで検索する</h3>
<p>独自のSQLを使用してレコードを検索したい場合、<code>find_by_sql</code>メソッドを強いようできます。この<code>find_by_sql</code>メソッドは、オブジェクトの配列を1つ返します。クエリがレコードを1つしか返さなかった場合にも配列が返されますのでご注意ください。たとえば、以下のクエリを実行したとします。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")

</pre>
</div>
<p><code>find_by_sql</code>は、カスタマイズしたデータベース呼び出しを簡単な方法で提供し、インスタンス化されたオブジェクトを返します。</p>
<h4 id="da9177abda199cc6e93fa67326c93fc9bdf82464">17.1 <code>select_all</code>
</h4>
<p><code>find_by_sql</code>は<code>connection#select_all</code>と深い関係があります。<code>select_all</code>は<code>find_by_sql</code>と同様、カスタムSQLを使用してデータベースからオブジェクトを取り出しますが、取り出したオブジェクトのインスタンス化を行わない点が異なります。代りに、ハッシュの配列を返します。1つのハッシュが1レコードを表します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")

</pre>
</div>
<h4 id="07542ad08b8353036c3f43fd7fbb4ea166f300fb">17.2 <code>pluck</code>
</h4>
<p><code>pluck</code>は、1つのモデルで使用されているテーブルから1つまたは複数のカラムをクエリするのに使用できます。引数としてカラム名のリストを取り、指定したカラムの値の配列を、対応するデータ型で返します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# =&gt; [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# =&gt; ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]

</pre>
</div>
<p><code>pluck</code>を使用すると、以下のようなコードをシンプルなものに置き換えることができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.select(:id).map { |c| c.id }
  # または
Client.select(:id).map(&amp;:id)
  # または
Client.select(:id, :name).map { |c| [c.id, c.name] }

</pre>
</div>
<p>上は以下に置き換えられます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.pluck(:id)
  # または
Client.pluck(:id, :name)

</pre>
</div>
<p><code>select</code>と異なり、<code>pluck</code>はデータベースから受け取った結果を直接Rubyの配列に変換してくれます。そのための<code>ActiveRecord</code>オブジェクトを事前に構成しておく必要はありません。従って、このメソッドは大規模なクエリや使用頻度の高いクエリで使用するとパフォーマンスが向上します。ただし、オーバーライドを行なうモデルメソッドは使用できません。例：</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Client &lt; ActiveRecord::Base
  def name
    "私は#{super}"
  end
end

Client.select(:name).map &amp;:name
# =&gt; ["私はDavid", "私はJeremy", "私はJose"]

Client.pluck(:name)
# =&gt; ["David", "Jeremy", "Jose"]

</pre>
</div>
<p>さらに<code>pluck</code>は、<code>select</code>などの<code>Relation</code>スコープと異なり、クエリを直接トリガするので、その後ろに他のスコープを連鎖することはできません。ただし、構成済みのスコープを<code>pluck</code>の前に置くことはできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.pluck(:name).limit(1)
# =&gt; NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;

Client.limit(1).pluck(:name)
# =&gt; ["David"]

</pre>
</div>
<h4 id="3adc09b3cd3d7c4710f562a05bd850e756cba1b8">17.3 <code>ids</code>
</h4>
<p><code>ids</code>は、テーブルの主キーを使用するリレーションのIDをすべて取り出すのに使用できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Person.ids
# SELECT id FROM people

</pre>
</div>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Person &lt; ActiveRecord::Base
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people

</pre>
</div>
<h3 id="6a25a0f94fd29020e437623892e55e8fb0a649ac">18 オブジェクトの存在チェック</h3>
<p>オブジェクトが存在するかどうかは、<code>exists?</code>メソッドでチェックできます。
このメソッドは、<code>find</code>と同様のクエリを使用してデータベースにクエリを送信しますが、オブジェクトのコレクションの代わりに<code>true</code>または<code>false</code>を返します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?(1)

</pre>
</div>
<p><code>exists?</code>は複数の値を引数に取ることができます。ただし、それらの値のうち1つでも存在していれば、他の値が存在していなくても<code>true</code>を返します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?(id: [1,2,3])
  # または
Client.exists?(name: ['John', 'Sergei'])

</pre>
</div>
<p><code>exists?</code>メソッドは、モデルやリレーションに対して引数なしで呼び出すことすらできます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Ryan').exists?

</pre>
</div>
<p>上の例では、<code>first_name</code>が'Ryan'のクライアントが1人でもいれば<code>true</code>を返し、それ以外の場合は<code>false</code>を返します。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.exists?

</pre>
</div>
<p>上の例では、<code>Client</code>テーブルが空なら<code>false</code>を返し、それ以外の場合は<code>true</code>を返します。</p>
<p>モデルやリレーションでの存在チェックには<code>any?</code>や<code>many?</code>も使用できます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# via a model
Post.any?
Post.many?

# 名前付きスコープを経由
Post.recent.any?
Post.recent.many?

# リレーション経由
Post.where(published: true).any?
Post.where(published: true).many?

# 関連付け経由
Post.first.categories.any?
Post.first.categories.many?

</pre>
</div>
<h3 id="c2bfc727f263555f4d523b8ec46ff97d8ac36d20">19 計算</h3>
<p>このセクションでは冒頭で<code>count</code>メソッドを例に取って説明していますが、ここで説明されているオプションは以下のすべてのサブセクションにも該当します。</p>
<p>あらゆる計算メソッドは、モデルに対して直接実行されます。All calculation methods work directly on a model:</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.count
# SELECT count(*) AS count_all FROM clients

</pre>
</div>
<p>リレーションに対しても直接実行されます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.where(first_name: 'Ryan').count
# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')

</pre>
</div>
<p>この他にも、リレーションに対してさまざまなファインダメソッドを使用して複雑な計算を行なうことができます。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count

</pre>
</div>
<p>上のコードは以下を実行します。</p>
<div class="code_container">
<pre class="brush: sql; gutter: false; toolbar: false">
SELECT count(DISTINCT clients.id) AS count_all FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
  (clients.first_name = 'Ryan' AND orders.status = 'received')

</pre>
</div>
<h4 id="5cb355f0034d2cab93b851ef559183fc981e44eb">19.1 個数を数える</h4>
<p>モデルのテーブルに含まれるレコードの個数を数えるには<code>Client.count</code>を使用できます。返されるのはレコードの個数です。特定の年齢のクライアントの数を数えるのであれば、<code>Client.count(:age)</code>とします。</p>
<p>オプションについては、1つ上の<a href="#calculations">計算</a>セクションを参照してください。</p>
<h4 id="d1454ec0221e46f8a0f10116910c45d454860592">19.2 平均</h4>
<p>テーブルに含まれる特定の数値の平均を得るには、そのテーブルを持つクラスに対して<code>average</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.average("orders_count")

</pre>
</div>
<p>返される値は、そのフィールドの平均値です。通常3.14159265のような浮動小数点になります。</p>
<p>オプションについては、1つ上の<a href="#calculations">計算</a>セクションを参照してください。</p>
<h4 id="c0d224e7d5a80249cae39bd7df303bfa8178d931">19.3 最小値</h4>
<p>テーブルに含まれるフィールドの最小値を得るには、そのテーブルを持つクラスに対して<code>minimum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.minimum("age")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#calculations">計算</a>セクションを参照してください。</p>
<h4 id="0c5fcc52f1964e3da3538f4796d65659d8019aa1">19.4 最大値</h4>
<p>テーブルに含まれるフィールドの最大値を得るには、そのテーブルを持つクラスに対して<code>maximum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.maximum("age")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#calculations">計算</a>セクションを参照してください。</p>
<h4 id="1db118371c67e76c6733174f05fa65e2d00fbb88">19.5 合計</h4>
<p>テーブルに含まれるフィールドのすべてのレコードにおける合計を得るには、そのテーブルを持つクラスに対して<code>sum</code>メソッドを呼び出します。このメソッド呼び出しは以下のようなものになります。</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Client.sum("orders_count")

</pre>
</div>
<p>オプションについては、1つ上の<a href="#calculations">計算</a>セクションを参照してください。</p>
<h3 id="3c724550ef43da451a0b97d6da617dc5e771250d">20 EXPLAINを実行する</h3>
<p>リレーションによってトリガされるクエリでEXPLAINを実行することができます。たとえば、以下のコードでは、</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.where(id: 1).joins(:posts).explain

</pre>
</div>
<p>以下のような結果が生成されます。</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `posts` ON `posts`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 |             |
|  1 | SIMPLE      | posts | ALL   | NULL          | NULL    | NULL    | NULL  |    1 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
2 rows in set (0.00 sec)

</pre>
</div>
<p>上の結果はMySQLの場合です。</p>
<p>Active Recordは、データベースのシェルを模した整形済みのデータを出力します。PostgreSQLアダプタで同じクエリを実行すると、今度は以下のような結果が得られます。</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (posts.user_id = users.id)
   -&gt;  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   -&gt;  Seq Scan on posts  (cost=0.00..28.88 rows=8 width=4)
         Filter: (posts.user_id = 1)
(6 rows)

</pre>
</div>
<p>一括読み込みを使用していると、内部で複数のクエリがトリガされることがあり、一部のクエリではその前の結果を必要とすることがあります。このため、<code>explain</code>はこのクエリを実際に実行し、それからクエリプランを要求します。たとえば、以下のコードでは、</p>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
User.where(id: 1).includes(:posts).explain

</pre>
</div>
<p>以下の結果を生成します。</p>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 |       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
1 row in set (0.00 sec)

EXPLAIN for: SELECT `posts`.* FROM `posts`  WHERE `posts`.`user_id` IN (1)
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | posts | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)

</pre>
</div>
<p>上の結果はMySQLの場合です。</p>
<h4 id="49e58308c3ccb67c8e3961eadaa51f3a1f461fca">20.1 EXPLAINの出力結果を解釈する</h4>
<p>EXPLAINの出力を解釈することは、本ガイドの範疇を超えます。以下の情報を参考にしてください。</p>
<ul>
<li><p>SQLite3: <a href="http://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li>
<li><p>MySQL: <a href="http://dev.mysql.com/doc/refman/5.6/en/explain-output.html">EXPLAIN Output Format</a></p></li>
<li><p>PostgreSQL: <a href="http://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li>
</ul>
</body></html>


        <h3>フィードバックについて</h3>
        <p>
          本ガイドの訳文およびソースコードは、GitHub上の <a href="https://github.com/yasslab/railsguides.jp">yasslab/railsguides.jp</a> で管理・公開されております。
	  本ガイドを読んで、誤字・脱字・誤訳などを見かけましたら、上記リポジトリにてお気軽に <a href="https://github.com/yasslab/railsguides.jp/issues">Issue</a> を出して頂けると大変嬉しいです。また、「Pull Request を送りたい!」という場合には、<a href="ruby_on_rails_guides_guidelines.html">Ruby on Railsガイドのガイドライン</a>と、<a href="https://github.com/yasslab/railsguides.jp#%E7%BF%BB%E8%A8%B3%E3%81%AE%E6%B5%81%E3%82%8C">README</a>に記載されている「翻訳の流れ」をご参考にしてください。
	</p>
	<p>
	  なお、原著レベルでの間違いを見つけましたら、原著へのフィードバック方法 (<a href="http://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a>) をご参考にしてください。
        </p>
        <p>
	  本ガイドの品質向上に向けて、皆さまのご協力が得られれば幸いです。よろしくお願い致します。
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
<p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>

    </div>
  </div>

  <script type="text/javascript" src="javascripts/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/responsive-tables.js"></script>
  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all();
    $(guidesIndex.bind);
  </script>
</body>
</html>
